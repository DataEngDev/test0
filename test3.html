<!DOCTYPE html> <!-- vim: set foldmethod=marker :-->
<html>
<!-- *** Head stuff {{{ -->
<!--[[[cog
import cog
from cogutil import *
import slides
include_file_default(classes="medium")
]]]-->
<!--[[[end]]]-->
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!-- Slide meta data, remove/edit as you see fit -->
    <title>Getting Started Testing</title>
    <meta charset="utf-8" />

    <!-- Slippy core file and dependencies -->
    <script type="text/javascript" src="slippy/jquery.min.js"></script>
    <script type="text/javascript" src="slippy/jquery.history.js"></script>
    <!-- Slippy slides -->
    <script type="text/javascript" src="slippy/slippy.js"></script>
    <script type="text/javascript" src="typogr.min.js"></script>

    <link type="text/css" rel="stylesheet" href="slippy/slippy.css"/>
    <link type="text/css" rel="stylesheet" href="slippy/slippy-pure.css"/>
    <!-- Our styles -->
    <link type="text/css" rel="stylesheet" href="slides.css"/>

    <!-- Highlight, for syntax coloring. -->
    <script type="text/javascript" src="highlight/highlight.pack.js"></script>
    <link rel="stylesheet" href="highlight/vs.css">

    <!-- Ned's slides init code -->
    <script type="text/javascript" src="lineselect.js"></script>

    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800|Permanent+Marker' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="slides.js"></script>

    <!-- Custom style for this deck -->
    <style type="text/css">
        .slide li.good:before {
            content: "✓   ";    /* U+2713 U+00A0 U+00A0 */
            color: #5b5;
            background-color: none; width: 0; height: 0; top: 0; right: 0;
        }
        .slide li.bad:before {
            content: "✘   ";    /* U+2718 U+00A0 U+00A0 */
            color: #d66;
            background-color: none; width: 0; height: 0; top: 0; right: 0;
        }
        .slide li.unsure:before {
            content: "⁈  ";    /* U+203D U+00A0 U+00A0 */
            color: #66d;
            background-color: none; width: 0; height: 0; top: 0; right: 0;
        }

        .abscontainer {
            position: relative;
            margin: -1em -5%;
        }
        .absleft {
            position: absolute;
            top: 0;
            left: 5%;
            width: 45%;
            padding-right: 5%;
            box-sizing: border-box;
        }
        .absright {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            padding-right: 5%;
            box-sizing: border-box;
        }
    </style>

</head>
<!-- }}} -->

<body class="slides">

<!-- *** Slide layouts {{{ -->

<div class="layout" data-name="clean">
    <content></content>
</div>

<div class="layout" data-name="default">
    <content></content>
    <div class="footer">
        <span class="left"><a class="implicit" href="https://bit.ly/pytest3" target="_blank">bit.ly<span class='punct'>/</span>pytest3</a></span>
        <span class="right"><a class="implicit" href="https://twitter.com/nedbat" target="_blank"><span class='punct'>@</span>nedbat</a></span>
        <hr class="defloat" />
    </div>
</div>

<!-- }}} -->

<!-- *** Introduction {{{ -->

<div class="slide title" data-layout="clean">
    <h1>Getting Started Testing</h1>
    <h2>
        Ned Batchelder<br/>
        <a class="implicit" href="https://twitter.com/nedbat">@nedbat</a>
        <br/>
        <a class="implicit" href="https://twitter.com/nedbat" target="_blank"><img class='icon' src='img/twitter.png' /></a>
        <a class="implicit" href="https://github.com/nedbat" target="_blank"><img class='icon' src='img/github.png' /></a>
        <br/><br/>
        <a class="implicit" href="https://bit.ly/pytest3"><span class="punct">http://</span>bit.ly<span class="punct">/</span>pytest3</a>
    </h2>
</div>

<div class="slide">
    <h1>Goals</h1>
    <ul>
        <li>Show you a way to test</li>
        <li>Remove mystery</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Writing correct code is complicated, it's hard.  How do you know when
    you've gotten it right, and how do you know your code has stayed right
    even after you've changed it?</p>

    <p>The best we know to do this is with automated testing.  Testing is a
    large topic, with its own tools and techniques.  It can be
    overwhelming.</p>

    <p>In this talk, I will show you how to write automated tests to test your
    Python code.  I'll start from scratch. By the time we're done here, you
    should have a mystery-free view of the basics and even a few advanced
    techniques, of automated testing.</p>

    <p>I'll include some pointers off to more advanced or exotic techniques,
    but you will have a good set of tools if you follow the methods shown
    here.</p>

    <p>The concepts covered here work the same in Python 2 or 3, though the
    code is Python 2.  In Python 3, a few imports and module names would
    have to change.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Why test?</h1>
    <ul>
        <li>Know if your code works</li>
        <li>Save time</li>
        <li>Better code</li>
        <li>Remove fear</li>
        <li>"Debugging is hard, testing is easy"</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>My main point here isn't to convince you to test, I hope you are reading
    this because you already know you want to do it.  But I have to say at
    least a little bit about why you should test.</p>

    <p>Automated testing is the best way we know to determine if your code
    works.  There are other techniques, like manual testing, or shipping it to
    customers and waiting for complaints, but automated testing works much
    better than those ways.</p>

    <p>Although writing tests is serious effort that takes real time, in
    the long run it will let you produce software faster because it makes your
    development process more predictable, and you'll spend less time fighting
    expensive fires.</p>

    <p>Testing also gives you another view into your code, and will probably
    help you write just plain better code.  The tests force you to think about
    the structure of your code, and you will find better ways to modularize
    it.</p>

    <p>Lastly, testing removes fear, because your tests are a safety net that
    can tell you early when you have made a mistake and set you back on the
    right path.</p>

</div><!-- }}} -->

<div class="slide">
    <p class="incremental" style='font-family: "Permanent Marker"; font-size: 450%; text-align: center; color: red; margin-top:0'>I&nbsp;  AM&nbsp;  BAD!</p>
    <p class="incremental" style='font-family: "Permanent Marker"; font-size: 200%; text-align: center; color: red; margin-top:0; letter-spacing: .05em'>and I should feel bad</p>
    <p class="incremental" style='text-align: center'><img src='img/dadtoon-iambad-3.png' width="50%"/></p>
</div>

<div class="text"><!-- {{{ -->

    <p>If you are like most developers, you know that you should be writing
    tests, but you aren't, and you feel bad about it.  Tests are the dental
    floss of development: everyone knows they should do it more, but they
    don't, and they feel guilty about it.</p>

    <p>BTW: illustrations by my son Ben!</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Yeah, it's hard</h1>
    <ul>
        <li class="incremental">A lot of work</li>
        <li class="incremental">People (you) won't want to</li>
        <li class="incremental">But: it pays off</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>It's true, testing is not easy.  It's real engineering that takes
    real thought and hard work.  But it pays off in the end.</p>

    <p>How often have you heard someone say, "I wrote a lot of tests, but it
    wasn't worth it, so I deleted them."  They don't.  Tests are good.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Chaos!</h1>
    <p style='text-align: center; margin-top:-1em'><img src='img/dadtoon-chaos-2.png' width="60%"/></p>
</div>

<div class="text"><!-- {{{ -->

    <p>The fact is that developing software is a constant battle against chaos,
    in all sorts of little ways.  You carefully organize your ideas in lines of
    code, but things change.  You add extra lines later, and they don't quite
    work as you want.  New components are added to the system and your previous
    assumptions are invalidated.  The services you depended on shift
    subtly.</p>

    <p>You know the feeling: on a bad day, it seems like everything is out to
    get you, the world is populated by gremlins and monsters, and they are all
    trying to get at your code.</p>

    <p>You have to fight that chaos, and the weapon you have is automated
    tests.</p>

    <p>OK, enough of the sermon, let's talk about how to write tests.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Roadmap</h1>
    <ul>
        <li>Growing tests</li>
        <li>pytest</li>
        <li>Test doubles</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>The rest of the talk is divided into three parts:</p>

    <ol>
        <li>We'll grow some tests in an ad-hoc way, examining what's good and
            bad about the style of code we get,</li>
        <li>we'll use unittest to write tests the right way,</li>
        <li>and we'll talk about a more advanced topic, mocks.</li>
    </ol>

</div><!-- }}} -->

<!-- }}} -->

<!-- *** Grow a first test {{{ -->
<div class="slide section" data-layout="clean">
    <h1>First principles</h1>
    <h2>Growing tests</h2>
</div>

<div class="text"><!-- {{{ -->

    <p>We'll start with a real (if tiny) piece of code, and start testing
    it.  First we'll do it manually, and then grow in sophistication from there,
    adding to our tests to solve problems we see along the way.</p>

    <p>Keep in mind, the first few iterations of these tests are not the good
    way to write tests.  I'll let you know when we've gotten to the right
    way!</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Stock portfolio class</h1>
    <!--[[[cog include_file("portfolio1.py") ]]] {{{ -->
    <pre class='python medium'>
    # portfolio1.py

    class Portfolio:
        """A simple stock portfolio"""
        def __init__(self):
            # A list of lists: [[name, shares, price], ...]
            self.stocks = []

        def buy(self, name, shares, price):
            """Buy shares at a certain price."""
            self.stocks.append([name, shares, price])

        def cost(self):
            """What was the total cost of this portfolio?"""
            amt = 0.0
            for name, shares, price in self.stocks:
                amt += shares * price
            return amt
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>Here is our code under test, a simple stock portfolio class.  It simply
    stores the lots of stocks purchased: each is a stock name, a number of
    shares, and the price it was bought at.  We have a method to buy a stock,
    and a method that tells us the total cost of the portfolio:</p>

<!--[[[cog include_file("portfolio1.py", px=True) ]]] {{{ -->
<code lang='python'>
# portfolio1.py

class Portfolio:
    """A simple stock portfolio"""
    def __init__(self):
        # A list of lists: [[name, shares, price], ...]
        self.stocks = []

    def buy(self, name, shares, price):
        """Buy shares at a certain price."""
        self.stocks.append([name, shares, price])

    def cost(self):
        """What was the total cost of this portfolio?"""
        amt = 0.0
        for name, shares, price in self.stocks:
            amt += shares * price
        return amt
</code>
<!--[[[end]]] }}}-->

</div><!-- }}} -->

<div class="slide">
    <h1>First test: interactive</h1>
    <!-- ** Interactive session {{{ -->
    <!--[[[cog
    prompt_session("""\
        p = Portfolio()
        p.cost()

        p.buy("IBM", 100, 176.48)
        p.cost()

        p.buy("HPQ", 100, 36.15)
        p.cost()
        """,
        prelude="""\
        from portfolio1 import Portfolio
        """)
    ]]]-->
    <pre class='python console medium'>
    &gt;&gt;&gt; p = Portfolio()
    &gt;&gt;&gt; p.cost()
    0.0

    &gt;&gt;&gt; p.buy("IBM", 100, 176.48)
    &gt;&gt;&gt; p.cost()
    17648.0

    &gt;&gt;&gt; p.buy("HPQ", 100, 36.15)
    &gt;&gt;&gt; p.cost()
    21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <ul class="tight">
        <li class="good">Good: testing the code</li>
        <li class="bad">Bad: not repeatable</li>
        <li class="bad">Bad: labor intensive</li>
        <li class="bad">Bad: is it right?</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>For our first test, we just run it manually in a Python prompt.  This is
    where most programmers start with testing: play around with the code and
    see if it works.</p>

    <p>Running it like this, we can see that it's right.  An empty portfolio
    has a cost of zero.  We buy one stock, and the cost is the price times the
    shares. Then we buy another, and the cost has gone up as it should.</p>

    <p>This is good, we're testing the code.  Some developers wouldn't have
    even taken this step!  But it's bad because it's not repeatable.  If
    tomorrow we make a change to this code, it's hard to make sure that we'll
    run the same tests and cover the same conditions that we did today.</p>

    <p>It's also labor intensive: we have to type these function calls each
    time we want to test the class.  And how do we know the results are right?
    We have to carefully examine the output, and get out a calculator, and see
    that the answer is what we expect.</p>

    <p>So we have one good quality, and three bad ones.  Let's improve the
    situation.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Second test: standalone</h1>
    <!--[[[cog include_file("porttest1.py")   ]]] {{{ -->
    <pre class='python medium'>
    # porttest1.py
    from portfolio1 import Portfolio

    p = Portfolio()
    print(f"Empty portfolio cost: {p.cost()}")
    p.buy("IBM", 100, 176.48)
    print(f"With 100 IBM @ 176.48: {p.cost()}")
    p.buy("HPQ", 100, 36.15)
    print(f"With 100 HPQ @ 36.15: {p.cost()}")
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("porttest1.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ python porttest1.py
    Empty portfolio cost: 0.0
    With 100 IBM @ 176.48: 17648.0
    With 100 HPQ @ 36.15: 21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <ul class="tight">
        <li class="good">Good: testing the code</li>
        <li class="good">Better: repeatable</li>
        <li class="good">Better: low effort</li>
        <li class="bad">Bad: is it right?</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Instead of typing code into a Python prompt, let's make a separate file
    to hold test code.  We'll do the same series of steps as before, but
    they'll be recorded in our test file, and we'll print the results we
    get:</p>

<!--[[[cog include_file("porttest1.py", px=True) ]]] {{{ -->
<code lang='python'>
# porttest1.py
from portfolio1 import Portfolio

p = Portfolio()
print(f"Empty portfolio cost: {p.cost()}")
p.buy("IBM", 100, 176.48)
print(f"With 100 IBM @ 176.48: {p.cost()}")
p.buy("HPQ", 100, 36.15)
print(f"With 100 HPQ @ 36.15: {p.cost()}")
</code>
<!--[[[end]]] }}}-->

    <p>When we run it, we get:</p>

<!--[[[cog include_file("porttest1.out", px=True) ]]] {{{ -->
<code lang='text'>
$ python porttest1.py
Empty portfolio cost: 0.0
With 100 IBM @ 176.48: 17648.0
With 100 HPQ @ 36.15: 21263.0
</code>
<!--[[[end]]] }}}-->

    <p>This is better because it's repeatable, since we can run this test file
    any time we want and have the same tests run every time.  And it's low
    effort: running a file is easy and quick.</p>

    <p>But we still don't know for sure that the answers are right unless we
    peer at the numbers printed and work out each time what they are supposed
    to be.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Third test: expected results</h1>
    <!--[[[cog include_file("porttest2.py", start=4)   ]]] {{{ -->
    <pre class='python medium'>
    p = Portfolio()
    print(f"Empty portfolio cost: {p.cost()}, should be 0.0")
    p.buy("IBM", 100, 176.48)
    print(f"With 100 IBM @ 176.48: {p.cost()}, should be 17648.0")
    p.buy("HPQ", 100, 36.15)
    print(f"With 100 HPQ @ 36.15: {p.cost()}, should be 21263.0")
    </pre>
    <!--[[[end]]] }}} -->
    <!--[[[cog include_file("porttest2.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ python porttest2.py
    Empty portfolio cost: 0.0, should be 0.0
    With 100 IBM @ 176.48: 17648.0, should be 17648.0
    With 100 HPQ @ 36.15: 21263.0, should be 21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <ul class="tight">
        <li class="good">Good: repeatable with low effort</li>
        <li class="good">Better: explicit expected results</li>
        <li class="bad">Bad: have to check the results yourself</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Here we've added to our test file so that in addition to printing the
    result it got, it prints the result it should have gotten:</p>

<!--[[[cog include_file("porttest2.py", px=True) ]]] {{{ -->
<code lang='python'>
# porttest2.py
from portfolio1 import Portfolio

p = Portfolio()
print(f"Empty portfolio cost: {p.cost()}, should be 0.0")
p.buy("IBM", 100, 176.48)
print(f"With 100 IBM @ 176.48: {p.cost()}, should be 17648.0")
p.buy("HPQ", 100, 36.15)
print(f"With 100 HPQ @ 36.15: {p.cost()}, should be 21263.0")
</code>
<!--[[[end]]] }}}-->

    <p>This is better: we don't have to calculate the expected results, they
    are recorded right there in the output:</p>

<!--[[[cog include_file("porttest2.out", px=True) ]]] {{{ -->
<code lang='text'>
$ python porttest2.py
Empty portfolio cost: 0.0, should be 0.0
With 100 IBM @ 176.48: 17648.0, should be 17648.0
With 100 HPQ @ 36.15: 21263.0, should be 21263.0
</code>
<!--[[[end]]] }}}-->

    <p>But we still have to examine all the output and compare the actual
    result to the expected result.  Keep in mind, the code here is very small,
    so it doesn't seem like a burden.  But in a real system, you might have
    thousands of tests.  You don't want to examine each one to see if the
    result is correct.</p>

    <p>This is still tedious work we have to do, we should get the computer to
    do it for us.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Fourth test: check results automatically</h1>
    <!--[[[cog include_file("porttest3.py", start=4)   ]]] {{{ -->
    <pre class='python medium'>
    p = Portfolio()
    print(f"Empty portfolio cost: {p.cost()}, should be 0.0")
    assert p.cost() == 0.0
    p.buy("IBM", 100, 176.48)
    print(f"With 100 IBM @ 176.48: {p.cost()}, should be 17648.0")
    assert p.cost() == 17648.0
    p.buy("HPQ", 100, 36.15)
    print(f"With 100 HPQ @ 36.15: {p.cost()}, should be 21263.0")
    assert p.cost() == 21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("porttest3.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ python porttest3.py
    Empty portfolio cost: 0.0, should be 0.0
    With 100 IBM @ 176.48: 17648.0, should be 17648.0
    With 100 HPQ @ 36.15: 21263.0, should be 21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <ul class="tight">
        <li class="good">Good: repeatable with low effort</li>
        <li class="good">Good: explicit expected results</li>
        <li class="good">Good: results checked automatically</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Here we've used the Python assert statement.  You may not have run
    across this before.  It takes a condition, and evaluates whether it's
    true or not.  If it's true, then execution continues onto the next
    statement.  If the condition is false, it raises an AssertionError
    exception:</p>

<!--[[[cog include_file("porttest3.py", px=True, start=4) ]]] {{{ -->
<code lang='python'>
p = Portfolio()
print(f"Empty portfolio cost: {p.cost()}, should be 0.0")
assert p.cost() == 0.0
p.buy("IBM", 100, 176.48)
print(f"With 100 IBM @ 176.48: {p.cost()}, should be 17648.0")
assert p.cost() == 17648.0
p.buy("HPQ", 100, 36.15)
print(f"With 100 HPQ @ 36.15: {p.cost()}, should be 21263.0")
assert p.cost() == 21263.0
</code>
<!--[[[end]]] }}}-->

    <p>So now we have the results checked automatically.  If one of the results
    is incorrect, the assert statement will raise an exception.</p>

    <p>Assertions like these are at the heart of automated testing, and you'll
    see a lot of them in real tests, though as we'll see, they take slightly
    different forms.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Fourth test: what failure looks like</h1>
    <!--[[[cog include_file("porttest3_broken.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ python porttest3_broken.py
    Empty portfolio cost: 0.0, should be 0.0
    With 100 IBM @ 176.48: 17648.0, should be 17600.0
    Traceback (most recent call last):
      File "porttest3_broken.py", line 9, in &lt;module&gt;
        assert p.cost() == 17600.0
    AssertionError
    </pre>
    <!--[[[end]]] }}}-->
    <ul class="tight">
        <li class="good">Good: repeatable with low effort</li>
        <li class="good">Good: expected results checked automatically</li>
        <li class="good">OK: failure visible, but cluttered output</li>
        <li class="bad">Bad: what was the wrong value?</li>
        <li class="bad">Bad: failure stops tests</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>There are a couple of problems with assertions like these.  First, all
    the successful tests clutter up the output.  You may think it's good to see
    all your successes, but it's not good if they obscure failures.  Second,
    when an assertion fails, it raises an exception, which ends our
    program:</p>

<!--[[[cog include_file("porttest3_broken.out", px=True) ]]] {{{ -->
<code lang='text'>
$ python porttest3_broken.py
Empty portfolio cost: 0.0, should be 0.0
With 100 IBM @ 176.48: 17648.0, should be 17600.0
Traceback (most recent call last):
  File "porttest3_broken.py", line 9, in &lt;module>
    assert p.cost() == 17600.0
AssertionError
</code>
<!--[[[end]]] }}}-->

    <p>We can only see a single failure, then the rest of the program is
    skipped, and we don't know the results of the rest of the tests.  This
    limits the amount of information our tests can give us.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Getting complicated!</h1>
    <ul>
        <li>Tests will grow</li>
        <li>Real programs</li>
        <li>Real engineering</li>
        <li>Handle common issues in standard ways</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>As you can see, we're starting to build up a real program here. To make
    the output hide successes, and continue on in the face of failures, you'll
    have to create a way to divide this test file into chunks, and run the
    chunks so that if one fails, others will still run.  It starts to get
    complicated.</p>

    <p>Anyone writing tests will face these problems, and common problems can
    often be solved with standard libraries. In the next section, we'll use
    unittest, from the Python standard library, to solve our common
    problems.</p>

</div><!-- }}} -->

<!-- }}} -->

<!-- *** Using py.test {{{ -->

<div class="slide section" data-layout="clean">
    <h1>Test frameworks</h1>
    <h2>Writing and running tests</h2>
</div>

<div class="slide">
    <h1>unittest</h1>
    <ul>
        <li>In the standard library</li>
        <li>Based on test classes</li>
        <li>Patterned on xUnit</li>
        <li>Wordy, "not Pythonic"</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>The Python standard library provides the unittest module.  It gives
    us the infrastructure for writing well-structured tests.</p>

    <p>The design of unittest is modelled on the common xUnit pattern that is
    available in many different languages, notably jUnit for Java.  This gives
    unittest a more verbose feeling than many Python libraries.  Some people
    don't like this and prefer other styles of tests, but unittest is by far
    the most widely used library, and is well-supported by every test tool.</p>

    <p>There are alternatives to unittest, but it's a good foundation to build
    on.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>nose</h1>
    <ul>
        <li>Was popular</li>
        <li>Unmaintained for years</li>
        <li><b>Do not use!</b></li>
    </ul>
</div>


<div class="slide">
    <h1>pytest</h1>
    <ul>
        <li>Third-party test runner</li>
        <li>Functions instead of classes</li>
        <li>Can be quirky</li>
        <li>Also runs unittest tests</li>
    </ul>
</div>


<div class="slide">
    <h1>Project structure</h1>
    <pre>
        ├── my_awesome_product
        │   ├── __init__.py
        │   ├── a_thing.py
        │   ├── another_thing.py
        │   ├── more_things.py
        │   └── other_things.py
        ├── README.rst
        ├── setup.py
        └── tests
            ├── __init__.py                  <span class='c'># maybe...</span>
            ├── test_a_thing.py
            ├── test_another_thing.py
            ├── test_more_things.py
            └── test_other_things.py
    </pre>
    <ul>
        <li>Separate "tests" directory</li>
        <li>Files named "test_*.py"</li>
    </ul>
</div>


<div class="slide">
    <h1>Running tests</h1>
    <ul>
        <li>Test runners can find your tests</li>
    </ul>
    <!--[[[cog
    include_code("""\
        $ pytest                            # .. for pytest


        $ python -m unittest discover       # .. for unittest
    """, lang="console")
    ]]]-->
    <pre class='console'>
    $ pytest                            # .. for pytest


    $ python -m unittest discover       # .. for unittest
    </pre>
    <!--[[[end]]]-->
</div>


<div class="slide">
    <h1>A simple unit test</h1>
    <!--[[[cog include_file("test_port1_pytest.py")   ]]] {{{ -->
    <pre class='python medium'>
    # test_port1_pytest.py

    from portfolio1 import Portfolio

    def test_buy_one_stock():
        p = Portfolio()
        p.buy("IBM", 100, 176.48)
        assert p.cost() == 17648.0
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("test_port1_pytest.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ pytest -q test_port1_pytest.py
    .                                                            [100%]
    1 passed in 0.01s
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li>Every "test_*" function is a test</li>
    </ul>
</div>

<div class="slide">
    <h1>Under the hood</h1>
    <!--[[[cog
    include_code("""\
        # pytest runs the tests as if I had written:
        try:
            test_buy_one_stock()
        except:
            [record failure]
        else:
            [record success]
    """, lang="python")
    ]]]-->
    <pre class='python'>
    # pytest runs the tests as if I had written:
    try:
        test_buy_one_stock()
    except:
        [record failure]
    else:
        [record success]
    </pre>
    <!--[[[end]]]-->
</div>

<div class="slide" data-layout="clean">
    <h1>Add more tests</h1>
    <!--[[[cog include_file("test_port2_pytest.py", start=5)   ]]] {{{ -->
    <pre class='python medium'>
    def test_empty():
        p = Portfolio()
        assert p.cost() == 0.0

    def test_buy_one_stock():
        p = Portfolio()
        p.buy("IBM", 100, 176.48)
        assert p.cost() == 17648.0

    def test_buy_two_stocks():
        p = Portfolio()
        p.buy("IBM", 100, 176.48)
        p.buy("HPQ", 100, 36.15)
        assert p.cost() == 21263.0
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("test_port2_pytest.out", hilite=["..."])   ]]] {{{ -->
    <pre class='text medium' data-hilite='|1|'>
    $ pytest -q test_port2_pytest.py
    ...                                                          [100%]
    3 passed in 0.01s
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li>A dot for every passed test</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>One test isn't enough, let's add some more.  Here we add a simpler test,
    test_empty, and a more complicated test, test_buy_two_stocks.  Each test is
    another test method in our PortfolioTest class:</p>

<!--[[[cog include_file("test_port2_pytest.py", px=True) ]]] {{{ -->
<code lang='python'>
# test_port2_pytest.py

from portfolio1 import Portfolio

def test_empty():
    p = Portfolio()
    assert p.cost() == 0.0

def test_buy_one_stock():
    p = Portfolio()
    p.buy("IBM", 100, 176.48)
    assert p.cost() == 17648.0

def test_buy_two_stocks():
    p = Portfolio()
    p.buy("IBM", 100, 176.48)
    p.buy("HPQ", 100, 36.15)
    assert p.cost() == 21263.0
</code>
<!--[[[end]]] }}}-->

    <p>Each one creates the portfolio object it needs, performs the
    manipulations it wants, and makes assertions about the outcome.</p>

    <p>When you run the tests, it prints a dot for every test that passes,
    which is why you see "..." in the test output here:</p>

<!--[[[cog include_file("test_port2_pytest.out", px=True) ]]] {{{ -->
<code lang='text'>
$ pytest -q test_port2_pytest.py
...                                                          [100%]
3 passed in 0.01s
</code>
<!--[[[end]]] }}}-->

</div><!-- }}} -->

<div class="slide" data-layout="clean">
    <h1>Under the hood</h1>
    <!--[[[cog
    include_code("""\
        # pytest runs the tests as if I had written:
        try:
            test_empty()
        except:
            [record failure]
        else:
            [record success]

        try:
            test_buy_one_stock()
        except:
            [record failure]
        else:
            [record success]

        try:
            test_buy_two_stocks()
        except:
            [record failure]
        else:
            [record success]
    """, lang="python", hilite=[2,9,16])
    ]]]-->
    <pre class='python' data-hilite='|2|9|16|'>
    # pytest runs the tests as if I had written:
    try:
        test_empty()
    except:
        [record failure]
    else:
        [record success]

    try:
        test_buy_one_stock()
    except:
        [record failure]
    else:
        [record success]

    try:
        test_buy_two_stocks()
    except:
        [record failure]
    else:
        [record success]
    </pre>
    <!--[[[end]]]-->
</div>

<div class="text"><!-- {{{ -->
    <p>With three tests, the execution model is much as before.  The key
    thing to note here is that a new instance of PortfolioTest is created
    for each test method.  This helps to guarantee an important property of
    good tests: isolation.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Test isolation</h1>
    <ul>
        <li>Tests don't affect each other</li>
        <li>Failure doesn't stop next tests</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Test isolation means that each of your tests is unaffected by every
    other test. This is good because it makes your tests more repeatable, and
    they are clearer about what they are testing. It also means that if a
    test fails, you don't have to think about all the conditions and data
    created by earlier tests: running just that one test will reproduce the
    failure.</p>

    <p>Earlier we had a problem where one test failing prevented the other
    tests from running.  Here unittest is running each test independently, so
    if one fails, the rest will run, and will run just as if the earlier test
    had succeeded.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>What failure looks like</h1>
    <!--[[[cog include_file("test_port2_pytest_broken.out", hilite=[".F.", "assert"])   ]]] {{{ -->
    <pre class='text medium' data-hilite='|1|8|9|'>
    $ pytest -q test_port2_pytest_broken.py
    .F.                                                          [100%]
    ============================= FAILURES =============================
    ________________________ test_buy_one_stock ________________________

        def test_buy_one_stock():
            p = Portfolio()
            p.buy("IBM", 100, 176)      # this is wrong, to make the test fail!
    &gt;       assert p.cost() == 17648.0
    E       assert 17600.0 == 17648.0
    E        +  where 17600.0 = &lt;bound method Portfolio.cost of &lt;portfolio1.Portfolio object at 0x1b01dface&gt;&gt;()
    E        +    where &lt;bound method Portfolio.cost of &lt;portfolio1.Portfolio object at 0x1b01dface&gt;&gt; = &lt;portfolio1.Portfolio object at 0x1b01dface&gt;.cost

    test_port2_pytest_broken.py:12: AssertionError
    1 failed, 2 passed in 0.01s
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li class="good">Good: failed test didn't stop others</li>
        <li class="good">Good: shows the value returned</li>
        <li class="unsure">Wow: automatic display of values</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>So far, all of our tests have passed.  What happens when they fail?</p>

<!--[[[cog include_file("test_port2_pytest_broken.out", px=True) ]]] {{{ -->
<code lang='text'>
$ pytest -q test_port2_pytest_broken.py
.F.                                                          [100%]
============================= FAILURES =============================
________________________ test_buy_one_stock ________________________

    def test_buy_one_stock():
        p = Portfolio()
        p.buy("IBM", 100, 176)      # this is wrong, to make the test fail!
>       assert p.cost() == 17648.0
E       assert 17600.0 == 17648.0
E        +  where 17600.0 = &lt;bound method Portfolio.cost of &lt;portfolio1.Portfolio object at 0x1b01dface>>()
E        +    where &lt;bound method Portfolio.cost of &lt;portfolio1.Portfolio object at 0x1b01dface>> = &lt;portfolio1.Portfolio object at 0x1b01dface>.cost

test_port2_pytest_broken.py:12: AssertionError
1 failed, 2 passed in 0.01s
</code>
<!--[[[end]]] }}}-->

    <p>The test runner prints a dot for every test that passes, and it prints
    an "F" for each test failure, so here we see ".F." in the output.  Then
    for each test failure, it prints the name of the test, and the traceback
    of the assertion failure.</p>

    <p>This style of test output means that test successes are very quiet, just
    a single dot.  When a test fails, it stands out, and you can focus on them.
    Remember: when your tests pass, you don't have to do anything, you can go
    on with other work, so passing tests, while a good thing, should not cause
    a lot of noise.  It's the failing tests we need to think about.</p>

    <p>It's great that the traceback shows what assertion failed, but notice
    that it doesn't tell us what bad value was returned.  We can see that we
    expected it to be 17648.0, but we don't know what the actual value was.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Testing for exceptions</h1>
    <ul>
        <li>Can't just call the function</li>
    </ul>
    <!--[[[cog include_file("test_port4_pytest_broken.py", start_from="test_bad_input", end_at="buy")   ]]] {{{ -->
    <pre class='python medium'>
    def test_bad_input():
        p = Portfolio()
        p.buy("IBM")
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("test_port4_pytest_broken.out", hilite=["TypeError"])   ]]] {{{ -->
    <pre class='text medium' data-hilite='|8|10|'>
    $ pytest -q test_port4_pytest_broken.py
    ...F                                                         [100%]
    ============================= FAILURES =============================
    __________________________ test_bad_input __________________________

        def test_bad_input():
            p = Portfolio()
    &gt;       p.buy("IBM")
    E       TypeError: buy() missing 2 required positional arguments: 'shares' and 'price'

    test_port4_pytest_broken.py:22: TypeError
    1 failed, 3 passed in 0.01s
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>Here we try to write an automated test of an error case: calling a
    method with too few arguments:</p>

<!--[[[cog include_file("test_port4_pytest_broken.py", start_from="test_bad_input", end_at="buy", px=True) ]]] {{{ -->
<code lang='python'>
def test_bad_input():
    p = Portfolio()
    p.buy("IBM")
</code>
<!--[[[end]]] }}}-->

    <p>This test won't do what we want.  When we call buy() with too few
    arguments, of course it raises TypeError, and there's nothing to catch the
    exception, so the test ends with an Error status:</p>

<!--[[[cog include_file("test_port4_pytest_broken.out", px=True) ]]] {{{ -->
<code lang='text'>
$ pytest -q test_port4_pytest_broken.py
...F                                                         [100%]
============================= FAILURES =============================
__________________________ test_bad_input __________________________

    def test_bad_input():
        p = Portfolio()
>       p.buy("IBM")
E       TypeError: buy() missing 2 required positional arguments: 'shares' and 'price'

test_port4_pytest_broken.py:22: TypeError
1 failed, 3 passed in 0.01s
</code>
<!--[[[end]]] }}}-->

    <p>That's not good, we want all our tests to pass.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>pytest.raises</h1>
    <!--[[[cog include_file("test_port4_pytest.py", start=22, end=26)   ]]] {{{ -->
    <pre class='python medium'>
    def test_bad_input():
        p = Portfolio()
        with pytest.raises(TypeError):
            p.buy("IBM")
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("test_port4_pytest.out")   ]]] {{{ -->
    <pre class='text medium'>
    $ pytest -q test_port4_pytest.py
    ....                                                         [100%]
    4 passed in 0.01s
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>To properly handle the error-raising function call, we use a method
    called assertRaises:</p>

<!--[[[cog include_file("test_port4_pytest.py", start=22, end=25, px=True) ]]] {{{ -->
<code lang='python'>
def test_bad_input():
    p = Portfolio()
    with pytest.raises(TypeError):
        p.buy("IBM")
</code>
<!--[[[end]]] }}}-->

    <p>This neatly captures our intent: we are asserting that a statement will
    raise an exception.  It's used as a context manager with a "with" statement
    so that it can handle the exception when it is raised:</p>

<!--[[[cog include_file("test_port4_pytest.out", px=True) ]]] {{{ -->
<code lang='text'>
$ pytest -q test_port4_pytest.py
....                                                         [100%]
4 passed in 0.01s
</code>
<!--[[[end]]] }}}-->

    <p>Now our test passes because the TypeError is caught by the assertRaises
    context manager.  The assertion passes because the exception raised is the
    same type we claimed it would be, and all is well.</p>

    <p>If you have experience with unittest before 2.7, the context manager
    style is new, and much more convenient than the old way.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Negative assertions</h1>
    <ul>
        <li>TODO</li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
</div>

<div class="slide section" data-layout="clean">
    <h1>Fixtures</h1>
    <h2>More structure</h2>
</div>


<div class="slide">
    <h1>More code:&#xa0; sell()</h1>
    <!--[[[cog include_file("portfolio2.py", start_from="def sell", end_at="You don't")   ]]] {{{ -->
    <pre class='python medium'>
    def sell(self, name, shares):
        """Sell some shares."""
        for holding in self.stocks:
            if holding[0] == name:
                if holding[1] &lt; shares:
                    raise ValueError("Not enough shares")
                holding[1] -= shares
                break
        else:
            raise ValueError("You don't own that stock")
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>Our testing is going well, time to extend our product.  Let's add
    a .sell() method to our Portfolio class.  It will remove shares of a
    particular stock from our Portfolio:</p>

<!--[[[cog include_file("portfolio2.py", start_from="def sell", end_at="You don't", px=True) ]]] {{{ -->
<code lang='python'>
def sell(self, name, shares):
    """Sell some shares."""
    for holding in self.stocks:
        if holding[0] == name:
            if holding[1] &lt; shares:
                raise ValueError("Not enough shares")
            holding[1] -= shares
            break
    else:
        raise ValueError("You don't own that stock")
</code>
<!--[[[end]]] }}}-->

    <p>Note: this code is very simple, for the purpose of fitting on a slide!</p>

</div><!-- }}} -->

<div class="slide" data-layout="clean">
    <!--[[[cog include_file("test_port5_pytest.py", start_from="test_sell")   ]]] {{{ -->
    <pre class='python medium'>
    def test_sell():
        p = Portfolio()
        p.buy("MSFT", 100, 27.0)
        p.buy("DELL", 100, 17.0)
        p.buy("ORCL", 100, 34.0)
        p.sell("MSFT", 50)
        assert p.cost() == 6450

    def test_not_enough():
        p = Portfolio()                 # Didn't I just do this?
        p.buy("MSFT", 100, 27.0)        #  |
        p.buy("DELL", 100, 17.0)        #  |
        p.buy("ORCL", 100, 34.0)        #  /
        with pytest.raises(ValueError):
            p.sell("MSFT", 200)

    def test_dont_own_it():
        p = Portfolio()                 # What, again!?!?
        p.buy("MSFT", 100, 27.0)        #  |
        p.buy("DELL", 100, 17.0)        #  |
        p.buy("ORCL", 100, 34.0)        #  /
        with pytest.raises(ValueError):
            p.sell("IBM", 1)
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>To test the .sell() method, we add three more tests.  In each case,
    we need to create a portfolio with some stocks in it so that we have
    something to sell:</p>

<!--[[[cog include_file("test_port5_pytest.py", start_from="test_sell", px=True) ]]] {{{ -->
<code lang='python'>
def test_sell():
    p = Portfolio()
    p.buy("MSFT", 100, 27.0)
    p.buy("DELL", 100, 17.0)
    p.buy("ORCL", 100, 34.0)
    p.sell("MSFT", 50)
    assert p.cost() == 6450

def test_not_enough():
    p = Portfolio()                 # Didn't I just do this?
    p.buy("MSFT", 100, 27.0)        #  |
    p.buy("DELL", 100, 17.0)        #  |
    p.buy("ORCL", 100, 34.0)        #  /
    with pytest.raises(ValueError):
        p.sell("MSFT", 200)

def test_dont_own_it():
    p = Portfolio()                 # What, again!?!?
    p.buy("MSFT", 100, 27.0)        #  |
    p.buy("DELL", 100, 17.0)        #  |
    p.buy("ORCL", 100, 34.0)        #  /
    with pytest.raises(ValueError):
        p.sell("IBM", 1)
</code>
<!--[[[end]]] }}}-->

    <p>But now our tests are getting really repetitve.  We've used the same
    four lines of code to create the same portfolio object three times.</p>

</div><!-- }}} -->


<div class="slide">
    <h1>Refactor using functions</h1>

    <!--[[[cog include_file("test_port5b_pytest.py", start_from="def simple_")   ]]] {{{ -->
    <pre class='python medium'>
    def simple_portfolio():
        p = Portfolio()
        p.buy("MSFT", 100, 27.0)
        p.buy("DELL", 100, 17.0)
        p.buy("ORCL", 100, 34.0)
        return p

    def test_sell():
        p = simple_portfolio()
        p.sell("MSFT", 50)
        assert p.cost() == 6450

    def test_not_enough():
        p = simple_portfolio()
        with pytest.raises(ValueError):
            p.sell("MSFT", 200)

    def test_dont_own_it():
        p = simple_portfolio()
        with pytest.raises(ValueError):
            p.sell("IBM", 1)
    </pre>
    <!--[[[end]]] }}} -->
</div>

<div class="slide">
    <h1>Arrange --- Act --- Assert</h1>

    <ul>
        <li>Three distinct phases</li>
        <li>Keep them separate</li>
    </ul>

    <!--[[[cog include_file("test_port5b_pytest.py", start_from="test_sell", end_at="assert")   ]]] {{{ -->
    <pre class='python medium'>
    def test_sell():
        p = simple_portfolio()
        p.sell("MSFT", 50)
        assert p.cost() == 6450
    </pre>
    <!--[[[end]]] }}} -->
</div>

<div class="slide">
    <h1>Fixtures</h1>
    <!--[[[cog include_file("test_port6_pytest.py", start_from="fixture")   ]]] {{{ -->
    <pre class='python medium'>
    @pytest.fixture
    def simple_portfolio():
        p = Portfolio()
        p.buy("MSFT", 100, 27.0)
        p.buy("DELL", 100, 17.0)
        p.buy("ORCL", 100, 34.0)
        return p

    def test_sell(simple_portfolio):
        simple_portfolio.sell("MSFT", 50)
        assert simple_portfolio.cost() == 6450

    def test_not_enough(simple_portfolio):
        with pytest.raises(ValueError):
            simple_portfolio.sell("MSFT", 200)

    def test_dont_own_it(simple_portfolio):
        with pytest.raises(ValueError):
            simple_portfolio.sell("IBM", 1)
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li class="unsure">Fixture called based on argument name</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>This is a common problem, so unittest has a solution for us.  A test
    class can define a .setUp() method.  This method is invoked before each
    test method.  Because your test class is a class, you have a self object
    that you can create attributes on:</p>

<!--[[[cog include_file("test_port6_pytest.py", start_from="fixture", px=True) ]]] {{{ -->
<code lang='python'>
@pytest.fixture
def simple_portfolio():
    p = Portfolio()
    p.buy("MSFT", 100, 27.0)
    p.buy("DELL", 100, 17.0)
    p.buy("ORCL", 100, 34.0)
    return p

def test_sell(simple_portfolio):
    simple_portfolio.sell("MSFT", 50)
    assert simple_portfolio.cost() == 6450

def test_not_enough(simple_portfolio):
    with pytest.raises(ValueError):
        simple_portfolio.sell("MSFT", 200)

def test_dont_own_it(simple_portfolio):
    with pytest.raises(ValueError):
        simple_portfolio.sell("IBM", 1)
</code>
<!--[[[end]]] }}}-->

    <p>Here we have a .setup() method that creates a portfolio and stores it as
    self.p.  Then the three test methods can simply use the self.p portfolio.
    Note the three test methods are much smaller, since they share the common
    setup code in .setUp().</p>

    <p>Naturally, there's also a .tearDown() method that will be invoked when
    the test method is finished.  tearDown can clean up after a test, for
    example if your setUp created records in a database, or files on disk.  We
    don't need one here.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Under the hood</h1>
    <!--[[[cog
    include_code("""\
        try:
            # Call the fixtures
            simple_portfolio_value = simple_portfolio()
        except:
            [record error]
        else:
            try:
                # Call the test method
                test_sell(simple_portfolio_value)
            except:
                [record failure]
            else:
                [record success]
    """, lang="python", hilite=[2, 8])
    ]]]-->
    <pre class='python' data-hilite='|2|8|'>
    try:
        # Call the fixtures
        simple_portfolio_value = simple_portfolio()
    except:
        [record error]
    else:
        try:
            # Call the test method
            test_sell(simple_portfolio_value)
        except:
            [record failure]
        else:
            [record success]
    </pre>
    <!--[[[end]]]-->
</div>

<div class="text"><!-- {{{ -->

    <p>Here's the detail on how unittest runs the setUp, test_method, and
    tearDown methods.  A test case object is instantiated, and its .setUp() is
    run.  if it doesn't raise an exception, then the .test_method() is run,
    noting its outcome.  No matter what happens with the .test_method(), the
    tearDown() is run.</p>

    <p>This is an important reason to put clean up code in a tearDown() method:
    it will be run even if your test fails.  If you try to clean up after
    yourself at the end of your test method, then if the test fails, the
    clean up doesn't happen, and you may pollute other tests.</p>

</div><!-- }}} -->


<div class="slide">
    <h1>Fixture cleanup</h1>
    <div class='abscontainer'>
    <div class='absleft'>
    <pre class='python'>
    @pytest.fixture
    def a_thing():
        thing = make_thing()
        yield thing
        thing.clean_up()

    def test_1(a_thing):
        ...

    def test_2(a_thing):
        ...

    def test_3(a_thing):
        ...
    </pre>
    </div>

    <div class='incremental absright'>
    <pre class='python'>
    thing1 = make_thing()
    test_1(thing1)
    thing1.clean_up()

    thing2 = make_thing()
    test_2(thing2)
    thing2.clean_up()

    thing3 = make_thing()
    test_3(thing3)
    thing3.clean_up()
    </pre>
    </div>

    <div class='incremental absright'>
    <pre class='python'>
    thing1 = make_thing()
    try:
        test_1(thing1)
    finally:
        thing1.clean_up()

    thing2 = make_thing()
    try:
        test_2(thing2)
    finally:
        thing2.clean_up()

    thing3 = make_thing()
    try:
        test_3(thing3)
    finally:
        thing3.clean_up()
    </pre>
    </div>
    </div>
</div>

<div class="slide">
    <h1>Fixture scope</h1>
    <div class='abscontainer'>
    <div class='absleft'>
    <pre class='python'>
    @pytest.fixture(
        scope="session"
    )
    def costly_thing():
        thing = make_costly()
        yield thing
        thing.clean_up()

    def test_1(costly_thing):
        ...

    def test_2(costly_thing):
        ...

    def test_3(costly_thing):
        ...
    </pre>
    </div>

    <div class='absright'>
    <pre class='python'>
    thing = make_costly()
    test1(thing)
    test2(thing)
    test3(thing)
    thing.clean_up()
    </pre>
    </div>
    </div>
</div>

<div class="slide">
    <h1>Fixtures</h1>
    <ul>
        <li>Establish context</li>
        <li>Common pre- or post- work</li>
        <li>Isolation, even with failures</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>setUp and tearDown are important ways to write more concise tests, and
    more importantly, give you powerful tools for ensuring proper test
    isolation.</p>

    <p>If you find your setUp and tearDown methods getting elaborate, there are
    third party "fixture" libraries that can help automate the creation of
    test data and environments.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Parameterized tests</h1>
    <ul>
        <li>TODO</li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
</div>


<div class="slide">
    <h1>Tests are real code!</h1>
    <ul>
        <li>Helper functions, classes, etc.</li>
        <li>Can become significant</li>
        <li>Might need tests!</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>You can see as we add more capability to our tests, they are becoming
    significant, even with the help of unittest.  This is a key point to
    understand: writing tests is real engineering!</p>

    <p>If you approach your tests as boring paperwork to get done because
    everyone says you have to, you will be unhappy and you will have bad
    tests.</p>

    <p>You have to approach tests as valuable solutions to a real problem: how
    do you know if your code works?  And as a valuable solution, you will put
    real effort into it, designing a strategy, building helpers, and so on.</p>

    <p>In a well-tested project, it isn't unusual to have more lines of tests
    than you have lines of product code! It is definitely worthwhile to
    engineer those tests well.</p>

</div><!-- }}} -->

<!-- }}} -->

<!-- *** Coverage {{{ -->
<div class="hidden_slide section" data-layout="clean">
    <h1>Coverage</h1>
    <h2>Testing tests</h2>
</div>

<div class="hidden_slide">
    <h1>What code are you testing?</h1>
    <ul>
        <li>The goal: tests execute product code</li>
        <li>But do they really?</li>
        <li>How much of it?</li>
    </ul>
</div>

<div class="hidden_slide">
    <h1>Coverage measurement</h1>
    <ul>
        <li>Run your tests</li>
        <li>Track what parts of product code are executed</li>
        <li>Report on covered / not covered</li>
        <li>You find code not being tested</li>
        <li>Write more tests</li>
        <li>The world is better!</li>
    </ul>
</div>

<div class="hidden_slide">
    <h1>Running coverage.py</h1>
    <ul>
        <li>Install it from PyPI</li>
        <li><tt>coverage run my_prog.py arg ...</tt></li>
        <li><tt>coverage html</tt></li>
        <li>Or: &nbsp;<tt>pytest -&#x200b;-cov ...</tt></li>
    </ul>
</div>

<div class="hidden_slide">
    <h1>HTML report</h1>
    <iframe src='test0_static/htmlcov/index.html' style='background:white;width:100%;height:85%;'></iframe>
</div>

<div class="hidden_slide">
    <h1>Coverage can only tell you a few things</h1>
    <ul>
        <li>What lines were executed</li>
        <li>What branches were taken</li>
        <li>100% coverage is difficult to reach</li>
        <li>100% coverage doesn't tell you everything</li>
    </ul>
</div>

<div class="hidden_slide">
    <h1>What coverage can't tell you</h1>
    <ul>
        <li>Are you exercising all your data?</li>
        <li>Are you exercising all your HTML templates?</li>
        <li>Are you checking results properly?</li>
        <li>Are you hitting all edge conditions?</li>
        <li>Are you testing the right things?</li>
        <li>Are you building the right product?  ;-)</li>
    </ul>
</div>


<!-- }}} -->

<!-- *** Test doubles {{{ -->
<div class="slide section" data-layout="clean">
    <h1>Test doubles</h1>
    <h2>Focusing tests</h2>
</div>

<div class="text"><!-- {{{ -->

    <p>We've covered the basics of how to write tests.  There's more to it,
    but I want to skip ahead to a more advanced technique: mocking.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Testing small amounts of code</h1>
    <ul>
        <li>Systems are built in layers</li>
        <li>Components depend on each other</li>
        <li>How to test just one component?</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Any real-sized program is built in layers and components.  In the full
    system, each component uses a number of other components.  As we've
    discussed, the best tests focus on just one piece of code.  How can you
    test a component in isolation from all of the components it depends on?</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Dependencies are bad</h1>
    <ul>
        <li>More suspect code in each test</li>
        <li>Slow components</li>
        <li>Unpredictable components</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Dependencies among components are bad for testing.  They mean that when
    you are testing one component, you are actually testing it and all the
    components it depends on.  This is more code than you want to be thinking
    about when writing or debugging a test.</p>

    <p>Also, some components might be slow, which will make your tests slow,
    which makes it hard to write lots of tests that will be run frequently.</p>

    <p>Lastly, some components are unpredictable, which makes it hard to write
    repeatable tests.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Test Doubles</h1>
    <ul>
        <li>Replace a component's dependencies</li>
        <li>Focus on one component</li>
    </ul>
    <img src='img/mock.png'/>
</div>

<div class="text"><!-- {{{ -->

    <p>The solutions to these problems are known as test doubles: code that
    can stand in for real code during testing, kind of like stunt doubles in
    movies.</p>

    <p>The idea is to replace certain dependencies with doubles. During
    testing, you test the primary component, and avoid invoking the complex,
    time-consuming, or unpredictable dependencies, because they have been
    replaced.</p>

    <p>The result is tests that focus in on the primary component without
    involving complicating dependencies.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Portfolio: Real-time data</h1>
    <!--[[[cog include_file("portfolio3.py", start_from="current_prices", end_at="return total")   ]]] {{{ -->
    <pre class='python medium'>
    def current_prices(self):
        """Return a dict mapping names to current prices."""
        url = "https://api.worldtradingdata.com/api/v1/stock?symbol="
        url += ",".join(s[0] for s in sorted(self.stocks))
        url += self.SUFFIX
        data = urllib.request.urlopen(url).read().decode("utf-8")
        lines = data.splitlines()[1:]
        return { row[0]: float(row[3]) for row in csv.reader(lines) }

    def value(self):
        """Return the current value of the portfolio."""
        prices = self.current_prices()
        total = 0.0
        for name, shares, _ in self.stocks:
            total += shares * prices[name]
        return total
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="slide">
    <h1>Portfolio: Real-time data</h1>
    <!-- ** Interactive session {{{ -->
    <!--[[[cog
    prompt_session("""\
        p = Portfolio()
        p.buy("IBM", 100, 150.0)
        p.buy("HPQ", 100, 30.0)

        p.current_prices()

        p.value()
        """,
        prelude="""\
        from portfolio3 import Portfolio
        """)
    ]]]-->
    <pre class='python console medium'>
    &gt;&gt;&gt; p = Portfolio()
    &gt;&gt;&gt; p.buy("IBM", 100, 150.0)
    &gt;&gt;&gt; p.buy("HPQ", 100, 30.0)

    &gt;&gt;&gt; p.current_prices()
    {'HPQ': 21.32, 'IBM': 143.73}

    &gt;&gt;&gt; p.value()
    16505.0
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>As an example, we'll add more code to our Portfolio class.  This code
    will tell us the actual real-world current value of our collection of
    stocks.  To do that, we've added a method called current_prices which
    uses a Yahoo web service to get the current market prices of the stocks
    we hold:</p>

<!--[[[cog include_file("portfolio3.py", start_from="current_prices", end_at="return total", px=True) ]]] {{{ -->
<code lang='python'>
def current_prices(self):
    """Return a dict mapping names to current prices."""
    url = "https://api.worldtradingdata.com/api/v1/stock?symbol="
    url += ",".join(s[0] for s in sorted(self.stocks))
    url += self.SUFFIX
    data = urllib.request.urlopen(url).read().decode("utf-8")
    lines = data.splitlines()[1:]
    return { row[0]: float(row[3]) for row in csv.reader(lines) }

def value(self):
    """Return the current value of the portfolio."""
    prices = self.current_prices()
    total = 0.0
    for name, shares, _ in self.stocks:
        total += shares * prices[name]
    return total
</code>
<!--[[[end]]] }}}-->

    <p>The new .value() method will get the current prices, and sum up the
    value of each stock holding to tell us the current value.</p>

    <p>Here we can try out our code manually, and see that current_prices()
    really does return us a dictionary of market prices, and .value() computes
    the value of the portfolio using those market prices.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>But how to test it?</h1>
    <ul>
        <li>Live data: unpredictable</li>
        <li>Slow?</li>
        <li>Unavailable?</li>
        <li>Question should be:
            <ul>
                <li>"Assuming the API is working,</li>
                <li>does my code work?"</li>
            </ul></li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>This simple example gives us all the problems of difficult dependencies
    in a nutshell.  Our product code is great, but depends on an external web
    service run by a third party.  It could be slow to contact, it could be
    unavailable.  But even when it is working, it is impossible to predict what
    values it will return.  The whole point of this function is to give us
    real-world data as of the current moment, so how can you write a test that
    proves it is working properly?  You don't know in advance what values it
    will produce.</p>

    <p>If we actually contact Yahoo as part of our testing, then we are testing
    whether Yahoo is working properly as well as our own code.  We want to only
    test our own code.  Our test should tell us, if Yahoo is working properly,
    will our code work properly?</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Fake implementation of current_prices</h1>
    <!--[[[cog include_file("test_port7_pytest.py", start_from="fixture", start_nth=2)   ]]] {{{ -->
    <pre class='python medium'>
    @pytest.fixture
    def fake_prices_portfolio(simple_portfolio):
        def fake_current_prices():
            return {'DELL': 140.0, 'ORCL': 32.0, 'MSFT': 51.0}
        simple_portfolio.current_prices = fake_current_prices
        return simple_portfolio

    def test_value(fake_prices_portfolio):
        assert fake_prices_portfolio.value() == 22300
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li class="good">Good: test results are predictable</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Our first test double will be a fake implementation of current_prices().
    In our setUp function, we create a Portfolio, and then we give it a
    new current_prices method that simply returns a fixed value:</p>

<!--[[[cog include_file("test_port7_pytest.py", start_from="fixture", start_nth=2, px=True) ]]] {{{ -->
<code lang='python'>
@pytest.fixture
def fake_prices_portfolio(simple_portfolio):
    def fake_current_prices():
        return {'DELL': 140.0, 'ORCL': 32.0, 'MSFT': 51.0}
    simple_portfolio.current_prices = fake_current_prices
    return simple_portfolio

def test_value(fake_prices_portfolio):
    assert fake_prices_portfolio.value() == 22300
</code>
<!--[[[end]]] }}}-->

    <p>This is very simple, and neatly solves a number of our problems: the
    code no longer contacts Yahoo, so it is fast and reliable, and it always
    produces the same value, so we can predict what values our .value() method
    should return.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Bad: un-tested code!</h1>
    <!--[[[cog include_file("test_port7_pytest.out", start_from="report", hilite=["portfolio3"])   ]]] {{{ -->
    <pre class='text medium' data-hilite='|3|'>
    $ coverage report -m
    Name                   Stmts   Miss  Cover   Missing
    ----------------------------------------------------
    portfolio3.py             34      6    82%   53-58
    test_port7_pytest.py      42      0   100%
    ----------------------------------------------------
    TOTAL                     76      6    92%
    </pre>
    <!--[[[end]]] }}}-->
    <!--[[[cog include_file("portfolio3.py", start_from="current_prices", end_at="return", number=True)   ]]] {{{ -->
    <pre class='python medium' data-numberfrom='51'>
    def current_prices(self):
        """Return a dict mapping names to current prices."""
        url = "https://api.worldtradingdata.com/api/v1/stock?symbol="
        url += ",".join(s[0] for s in sorted(self.stocks))
        url += self.SUFFIX
        data = urllib.request.urlopen(url).read().decode("utf-8")
        lines = data.splitlines()[1:]
        return { row[0]: float(row[3]) for row in csv.reader(lines) }
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>But we may have gone too far: none of our actual current_prices() method
    is tested now.  Here I've used <a href="http://nedbatchelder.com/code/coverage">coverage.py</a>
    to measure what product lines are executed during testing, and it shows us
    that lines 53 through 56 are not executed.  Those are the body of the
    current_prices() method.</p>

    <p>That's our code, and we need to test it somehow.  We got isolation from
    Yahoo, but we removed some of our own code in the process.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Fake urlopen instead</h1>
    <!--[[[cog include_file("test_port8_pytest.py", start_from="Fake")   ]]] {{{ -->
    <pre class='python medium'>
    class FakeUrllibRequest:
        # A simple fake for urlopen that is only good for one request.
        def urlopen(self, url):
            return BytesIO(b'\nDELL,,,140\nORCL,,,32\nMSFT,,,51\n')

    @pytest.fixture
    def fake_urllib_request():
        old_urllib_request = portfolio3.urllib.request
        portfolio3.urllib.request = FakeUrllibRequest()
        yield
        portfolio3.urllib.request = old_urllib_request

    def test_value(simple_portfolio, fake_urllib_request):
        assert simple_portfolio.value() == 22300
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>To test our code but still not use Yahoo, we can intercept the flow
    lower down.  Our current_prices() method uses the urllib module to make
    the HTTP request to Yahoo.  We can replace urllib to let our code run,
    but not make a real network request.</p>

    <p>Here we define a class called FakeUrlLib with a method called urlopen
    that will be the test double for urllib.urlopen().  Our fake implementation
    simply returns a file object that provides the same stream of bytes that
    Yahoo would have returned:</p>

<!--[[[cog include_file("test_port8_pytest.py", start_from="Fake", px=True) ]]] {{{ -->
<code lang='python'>
class FakeUrllibRequest:
    # A simple fake for urlopen that is only good for one request.
    def urlopen(self, url):
        return BytesIO(b'\nDELL,,,140\nORCL,,,32\nMSFT,,,51\n')

@pytest.fixture
def fake_urllib_request():
    old_urllib_request = portfolio3.urllib.request
    portfolio3.urllib.request = FakeUrllibRequest()
    yield
    portfolio3.urllib.request = old_urllib_request

def test_value(simple_portfolio, fake_urllib_request):
    assert simple_portfolio.value() == 22300
</code>
<!--[[[end]]] }}}-->

    <p>In our test's setUp() method, we replace the urllib reference in our
    product code with our fake implementation.  When the test method runs,
    our FakeUrlLib object will be invoked instead of the urllib module, it will
    return its canned response, and our code will process it just as if it had
    come from Yahoo.</p>

    <p>Notice that the product code uses a module with a function, and we are
    replacing it with an object with a method.  That's fine, Python's dynamic
    nature means that it doesn't matter what "urllib" is defined as, so long as
    it has a .urlopen attribute that is callable, the product code will be
    fine.</p>

    <p>This sort of manipulation is one place where Python really shines, since
    types and access protection don't constrain what we can do to create the
    test environment we want.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>All of our code is executed</h1>
    <!--[[[cog include_file("test_port8_pytest.out", start_from="report")   ]]] {{{ -->
    <pre class='text medium'>
    $ coverage report -m
    Name                   Stmts   Miss  Cover   Missing
    ----------------------------------------------------
    portfolio3.py             34      0   100%
    test_port8_pytest.py      47      0   100%
    ----------------------------------------------------
    TOTAL                     81      0   100%
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li class="good">Stdlib is stubbed</li>
        <li class="good">All our code is run</li>
        <li class="good">No web access during tests</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Now the coverage report shows that all of our code has been executed.
    By stubbing the standard library, we cut off the component dependencies
    at just the right point: where our code (current_prices) started calling
    someone else's code (urllib.urlopen).</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Mock objects</h1>
    <ul>
        <li>Automatic chameleons</li>
        <li>Act like any object</li>
        <li>Record what happened to them</li>
        <li>You can make assertions afterward</li>
    </ul>
    <!-- ** Interactive session {{{ -->
    <!--[[[cog
    prompt_session("""\
        from mock import Mock

        func = Mock()
        func.return_value = "Hello!"

        func(17, "something")

        func.call_args
        """)
    ]]]-->
    <pre class='python console medium'>
    &gt;&gt;&gt; from mock import Mock

    &gt;&gt;&gt; func = Mock()
    &gt;&gt;&gt; func.return_value = "Hello!"

    &gt;&gt;&gt; func(17, "something")
    'Hello!'

    &gt;&gt;&gt; func.call_args
    call(17, 'something')
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="text"><!-- {{{ -->

    <p>A more powerful way to create test doubles is with Mock objects.
    The mock library (third-party for 2.7, in the standard library for 3.3)
    provides the Mock class.  This object will happily act like any object
    you please.  You can set a return_value on it, and when called, it will
    return that value.  Then you can ask what arguments it was called with.</p>

    <p>Mock objects can do other magic things, but these two behaviors give us
    what we need for now.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Mocking with no setup</h1>
    <!--[[[cog include_file("test_port9_pytest.py", start_from="test_value")   ]]] {{{ -->
    <pre class='python medium'>
    def test_value(simple_portfolio, mocker):
        urlopen = mocker.patch(
            "portfolio3.urllib.request.urlopen",
            side_effect=[BytesIO(b'\nDELL,,,140\nORCL,,,32\nMSFT,,,51\n')],
        )
        assert simple_portfolio.value() == 22300

        assert len(urlopen.call_args_list) == 1
        opened_url = urlopen.call_args_list[0][0][0]
        assert "api.worldtradingdata.com/api/v1/stock" in opened_url
        assert "symbol=DELL,MSFT,ORCL" in opened_url
    </pre>
    <!--[[[end]]] }}}-->
    <ul>
        <li>No fixture needed</li>
        <li>mock from pytest-mock</li>
    </ul>
</div>

<div class="text"><!-- {{{ -->

    <p>Here's a new test of our current_prices code:</p>

<!--[[[cog include_file("test_port9_pytest.py", start_from="test_value", px=True) ]]] {{{ -->
<code lang='python'>
def test_value(simple_portfolio, mocker):
    urlopen = mocker.patch(
        "portfolio3.urllib.request.urlopen",
        side_effect=[BytesIO(b'\nDELL,,,140\nORCL,,,32\nMSFT,,,51\n')],
    )
    assert simple_portfolio.value() == 22300

    assert len(urlopen.call_args_list) == 1
    opened_url = urlopen.call_args_list[0][0][0]
    assert "api.worldtradingdata.com/api/v1/stock" in opened_url
    assert "symbol=DELL,MSFT,ORCL" in opened_url
</code>
<!--[[[end]]] }}}-->

    <p>In our test method, we use a context manager provided by mock:
    mock.patch will replace the given name with a mock object, and give us the
    mock object so we can manipulate it.</p>

    <p>We mock out urllib.urlopen, and then set the value it should return. We
    use the same open file object that we did in the last example, which just
    mimics the bytes that Yahoo would return to us.</p>

    <p>Then we can run the product code, which will call current_prices, which
    will call urllib.urlopen, which is now our mock object.  It will return our
    mocked return value, and produce the expected portfolio value.</p>

    <p>Mock objects also have a handy method on them called
    .assert_called_with() that let us make assertions about the arguments the
    mock object was passed.  This gives us certainty that our code called the
    external component properly.</p>

    <p>When the with statement ends, the mock.patch context manager cleans up,
    restoring urllib.urlopen to it original value.</p>

    <p>The net result is a clean self-contained test double, with assertions
    about how it was called.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Test doubles: good</h1>
    <ul>
        <li class="incremental">Powerful: isolates code</li>
        <li class="incremental">Focuses tests</li>
        <li class="incremental">Removes speed bumps and randomness</li>
    </ul>
</div>

<div class="slide">
    <h1>Test doubles: bad</h1>
    <ul>
        <li class="incremental">Tied to implementation details</li>
        <li class="incremental">Can be fragile</li>
        <li class="incremental">Don't overdo it</li>
    </ul>
</div>


<div class="text"><!-- {{{ -->

    <p>Test doubles are a big topic all of their own.  I wanted to give you a
    quick taste of what they are and what they can do.  Using them will
    dramatically improve the isolation, and therefore the speed and usefulness
    of your tests.</p>

    <p>Notice though, that they also make our tests more fragile.  I tested
    current_prices by mocking urllib.urlopen, which only works because I knew
    that current_prices called urlopen.  If I later change the implementation
    of current_prices to access the URL differently, my test will break.</p>

    <p>Finding the right way to use test doubles is a very tricky problem,
    involving tradeoffs between what code is tested, and how dependent on the
    implementation you want to be.</p>

    <p>Another test double technique is "dependency injection," where your code
    is given explicit references to the components it relies on.  This way, the
    dependencies are made more visible.  This also makes them more visible to
    the non-test callers of the code, which you might not want.  But it can
    also make the code more modular, since it has fewer implicit connections to
    other components.  Again, this is a tradeoff, and you have to choose
    carefully how deeply to use the technique.</p>

</div><!-- }}} -->

<!-- }}} -->

<!-- *** Other topics {{{ -->

<div class="slide section" data-layout="clean">
    <h1>Also</h1>
    <h2>Too many things I couldn't fit!</h2>
</div>

<div class="text"><!-- {{{ -->
    <p>Testing is a huge topic, there are many paths to take from here.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Ideas</h1>
    <ul>
        <li>unit vs integration vs system vs end-to-end</li>
        <li>negative assertions</li>
        <li></li>
        <li></li>
    </ul>
</div>

<div class="slide">
    <h1>Tools</h1>
    <h3 class="incremental">coverage: <span style="font-weight: normal">you'll wonder how you lived without it</span></h3>
    <h3 class="incremental">doctest: <span style="font-weight: normal">only for testing docs!!!</span></h3>
    <h3 class="incremental">ddt: <span style="font-weight: normal">data-driven tests</span></h3>
    <h3 class="incremental">Selenium: <span style="font-weight: normal">in-browser testing</span></h3>
    <h3 class="incremental">Jenkins, Travis, CircleCI: <span style="font-weight: normal">run tests all the time</span></h3>
    <h3 class="incremental">tox: <span style="font-weight: normal">test multiple configurations</span></h3>
</div>

<div class="text"><!-- {{{ -->
    <p>Other tools:</p>

    <ul>

        <li><a href='https://docs.python.org/2/library/unittest.html#unittest.TestCase.addCleanup'>addCleanup</a>
        is a method on test cases.  It lets you register clean up functions to
        be called when the test is done.  This has the advantage that partially
        set up tests can be torn down, and you can register clean up functions
        in the body of tests if you like.</li>

        <li><a href='https://docs.python.org/2/library/doctest.html'>doctest</a>
        is another module in the standard library for writing tests.  It
        executes Python code embedded in docstrings.  Some people love it, but
        most developers think it should only be used for testing code that
        naturally appears in docstrings, and not for anything else.</li>

        <li><a href='https://nose.readthedocs.org/'>nose</a> and
        <a href='http://pytest.org'>pytest</a> are alternative test runners.
        They will run your unittest tests, but have a ton of extra features,
        and plugins.</li>

        <li><a href='http://ddt.readthedocs.org'>ddt</a> is a package for
        writing data-driven tests.  This lets you write one test method, then
        feed it a number of different data cases, and it will split out your
        test method into a number of methods, one for each data case.  This
        lets each one succeed or fail independently.</li>

        <li><a href='/code/coverage'>coverage.py</a> runs your code, and
        measures which lines executed and which did not.  This is a way of
        testing your tests to see how much of your product code is covered by
        your tests.</li>

        <li><a href='http://docs.seleniumhq.org/'>Selenium</a> is a tool for
        running tests of web sites.  It automates a browser to run your tests
        in an actual browser, so you can incorporate the behavior of Javascript
        code and browser behaviors into your tests.</li>

        <li><a href='http://jenkins-ci.org/'>Jenkins</a> and
        <a href='https://docs.travis-ci.org/'>Travis</a> are
        continuous-integration servers.  They run your test suite
        automatically, for example, whenever you make a commit to your repo.
        Running your tests automatically on a server lets your tests results be
        shared among all collaborators, and historical results kept for
        tracking progress.</li>

    </ul>
</div><!-- }}} -->

<div class="slide">
    <h1>Topics</h1>
    <h3 class="incremental">TDD: <span style="font-weight: normal">tests before code!?</span></h3>
    <h3 class="incremental">BDD: <span style="font-weight: normal">describe external behavior</span></h3>
    <h3 class="incremental">integration tests: <span style="font-weight: normal">bigger chunks</span></h3>
    <h3 class="incremental">load testing: <span style="font-weight: normal">how much traffic is OK?</span></h3>
    <h3 class="incremental">others, I'm sure....<span style="font-weight: normal"></span></h3>
</div>

<div class="text"><!-- {{{ -->
    <p>Other topics:</p>

    <ul>

        <li>Test-driven development (TDD) is a style of development where you
        write tests before you write your code.  This isn't so much to ensure
        that your code is tested as it is to give you a chance to think hard
        about how your code will be used before you write the code.  Advocates
        of the style claim your code will be better designed as a result, and
        you have the tests as a side-benefit.</li>

        <li>Behavior-driven development (BDD) uses specialized languages such
        as Cucumber and Lettuce to write tests.  These languages provide a
        higher level of description and focus on the external user-visible
        behavior of your product code.</li>

        <li>In this talk, I've focused on unit tests, which try to test as
        small a chunk of code as possible.  Integration tests work on larger
        chunks, after components have been integrated together.  The scale
        continues on to system tests (of the entire system), and acceptance
        tests (user-visible behavior).  There is no crisp distinction between
        these categories, they fall on a spectrum of scale.</li>

        <li>Load testing is the process of generating synthetic traffic to a
        web site or other concurrent system to determine its behavior as the
        traffic load increases.  Specialized tools can help generate the
        traffic and record response times as the load changes.</li>

    </ul>

    <p>There are plenty of other topics, I wish I had time and space to discuss
    them all!</p>

</div><!-- }}} -->

<!-- }}} -->


<div class="slide section" data-layout="clean">
    <h1>Summing up</h1>
</div>

<div class="slide">
    <h1>Testing is...</h1>
    <ul class="incremental">
        <li>Complicated</li>
        <li>Important</li>
        <li>Worthy</li>
        <li>Rewarding</li>
    </ul>
    <p class="incremental" style='text-align:right;margin-top:-3em'><img src='img/happysticks.png' width="50%"/></p>
</div>

<div class="text"><!-- {{{ -->

    <p>I hope this quick introduction has helped orient you in the world of
    testing.  Testing is a complicated pursuit, because it is trying to solve a
    difficult problem: determining if your code works.  If your code is
    anything interesting at all, then it is large and complex and involved, and
    determining how it behaves is a nearly impossible task.</p>

    <p>Writing tests is the process of crafting a program to do this
    impossible thing, so of course it is difficult.  But it needs to be done:
    how else can you know that your code is working, and stays working as you
    change it?</p>

    <p>From a pure engineering standpoint, writing a good test suite can itself
    be rewarding, since it is a technical challenge to study and overcome.</p>

    <p>Here are our two developers, happy and confident at last because they
    have a good set of tests.  (I couldn't get my son to draw me a third
    picture!)</p>

</div><!-- }}} -->


<!--
    Things to add:

    - Start writing tests for bugs you find.
    - Changing mindsets is hard.
        - How do you get people on board?
-->

<div class="slide title" data-layout="clean">
    <h1 style="padding-top: 0em">Questions?</h1>
    <h2 style="margin-top: 5em">
        <a class="implicit" href="https://twitter.com/nedbat">@nedbat</a>
        <br/>
        <a class="implicit" href="https://twitter.com/nedbat" target="_blank"><img class='icon' src='img/twitter.png' /></a>
        <a class="implicit" href="https://github.com/nedbat" target="_blank"><img class='icon' src='img/github.png' /></a>
    </h2>
    <h2><a class="implicit" href="https://bit.ly/pytest3"><span class="punct">http://</span>bit.ly<span class="punct">/</span>pytest3</a></h2>
    <div class="incremental" style="position:absolute;top:0;right:0">
    <p style='text-align:right'><img src='img/dadtoon-mii.png' width="50%"></p>
    <p style='text-align:right;font-size:85%;margin-top:0;padding-right:2em'>
    <i>Illustrations by<br/>Ben Batchelder</i>
    </p>
    </div>
</div>


</body>
</html>
<!-- TO DO:  {{{

    * Content
    - Something to replace the hidden Approaches section
    - Most common question: how do I convince my team to test?

    * Layout
    - URL footer on first few slides.



    # Getting Started Testing

    - Goal
        - Give you tools to start testing your code

    - Two challenges:
        - People
        - Code

    - Vegetables

    = People

    - Why test?
        - Best way to know if your code works
    - Resistance
        - More work
        - Hard to add to a legacy project
        - Not a developer's job?
    - Benefits
        - Confidence
        - Turns fear into boredom
        - Faster in the long run
    - Fighting Chaos!
    - How to start
        - Start with the easy
        - Start with the necessary

    = Code

    - 2 vs 3

    - How to write tests
        - Show *a* way to do it.
        - there are many techniques

    = First principles

    - Product code: stock portfolio

    - First test: interactive

    - Second test: standalone

    - Third test: with expected results

    - Fourth test: check results automatically

    - Getting complicated!

    = Unittest

    - unittest
        - stdlib
        - a good solid foundation
        - not the only way to do it
        - not about unit vs integration

    - Simple unit test

    = Test Doubles


    = Other stuff
    - doctest
    - coverage
    - nose, pytest, trial
    - lettuce
    - Selenium
    - ddt
    - TDD

}}} -->
